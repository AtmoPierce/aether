use crate::math::{Matrix, Vector};
use nalgebra::{SMatrix, SVector};

fn assert_close_f32(lhs: f32, rhs: f32, eps: f32) {
    assert!((lhs - rhs).abs() <= eps, "lhs={lhs} rhs={rhs} eps={eps}");
}

fn assert_close_f64(lhs: f64, rhs: f64, eps: f64) {
    assert!((lhs - rhs).abs() <= eps, "lhs={lhs} rhs={rhs} eps={eps}");
}

#[test]
fn matmul_simd_matches_nalgebra_f32() {
    let a = Matrix::<f32, 6, 6>::new([
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0],
        [2.0, 3.0, 4.0, 5.0, 6.0, 7.0],
        [3.0, 4.0, 5.0, 6.0, 7.0, 8.0],
        [4.0, 5.0, 6.0, 7.0, 8.0, 9.0],
        [5.0, 6.0, 7.0, 8.0, 9.0, 10.0],
        [6.0, 7.0, 8.0, 9.0, 10.0, 11.0],
    ]);
    let b = Matrix::<f32, 6, 6>::new([
        [11.0, 10.0, 9.0, 8.0, 7.0, 6.0],
        [10.0, 9.0, 8.0, 7.0, 6.0, 5.0],
        [9.0, 8.0, 7.0, 6.0, 5.0, 4.0],
        [8.0, 7.0, 6.0, 5.0, 4.0, 3.0],
        [7.0, 6.0, 5.0, 4.0, 3.0, 2.0],
        [6.0, 5.0, 4.0, 3.0, 2.0, 1.0],
    ]);

    let got = a.mul_matrix_simd(&b);

    let na_a = SMatrix::<f32, 6, 6>::from_row_slice(&[
        1.0, 2.0, 3.0, 4.0, 5.0, 6.0,
        2.0, 3.0, 4.0, 5.0, 6.0, 7.0,
        3.0, 4.0, 5.0, 6.0, 7.0, 8.0,
        4.0, 5.0, 6.0, 7.0, 8.0, 9.0,
        5.0, 6.0, 7.0, 8.0, 9.0, 10.0,
        6.0, 7.0, 8.0, 9.0, 10.0, 11.0,
    ]);
    let na_b = SMatrix::<f32, 6, 6>::from_row_slice(&[
        11.0, 10.0, 9.0, 8.0, 7.0, 6.0,
        10.0, 9.0, 8.0, 7.0, 6.0, 5.0,
        9.0, 8.0, 7.0, 6.0, 5.0, 4.0,
        8.0, 7.0, 6.0, 5.0, 4.0, 3.0,
        7.0, 6.0, 5.0, 4.0, 3.0, 2.0,
        6.0, 5.0, 4.0, 3.0, 2.0, 1.0,
    ]);
    let expected = na_a * na_b;

    for i in 0..6 {
        for j in 0..6 {
            assert_close_f32(got.data[i][j], expected[(i, j)], 1.0e-4);
        }
    }
}

#[test]
fn matmul_simd_matches_nalgebra_f64() {
    let a = Matrix::<f64, 6, 6>::new([
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0],
        [2.0, 3.0, 4.0, 5.0, 6.0, 7.0],
        [3.0, 4.0, 5.0, 6.0, 7.0, 8.0],
        [4.0, 5.0, 6.0, 7.0, 8.0, 9.0],
        [5.0, 6.0, 7.0, 8.0, 9.0, 10.0],
        [6.0, 7.0, 8.0, 9.0, 10.0, 11.0],
    ]);
    let b = Matrix::<f64, 6, 6>::new([
        [11.0, 10.0, 9.0, 8.0, 7.0, 6.0],
        [10.0, 9.0, 8.0, 7.0, 6.0, 5.0],
        [9.0, 8.0, 7.0, 6.0, 5.0, 4.0],
        [8.0, 7.0, 6.0, 5.0, 4.0, 3.0],
        [7.0, 6.0, 5.0, 4.0, 3.0, 2.0],
        [6.0, 5.0, 4.0, 3.0, 2.0, 1.0],
    ]);

    let got = a.mul_matrix_simd(&b);

    let na_a = SMatrix::<f64, 6, 6>::from_row_slice(&[
        1.0, 2.0, 3.0, 4.0, 5.0, 6.0,
        2.0, 3.0, 4.0, 5.0, 6.0, 7.0,
        3.0, 4.0, 5.0, 6.0, 7.0, 8.0,
        4.0, 5.0, 6.0, 7.0, 8.0, 9.0,
        5.0, 6.0, 7.0, 8.0, 9.0, 10.0,
        6.0, 7.0, 8.0, 9.0, 10.0, 11.0,
    ]);
    let na_b = SMatrix::<f64, 6, 6>::from_row_slice(&[
        11.0, 10.0, 9.0, 8.0, 7.0, 6.0,
        10.0, 9.0, 8.0, 7.0, 6.0, 5.0,
        9.0, 8.0, 7.0, 6.0, 5.0, 4.0,
        8.0, 7.0, 6.0, 5.0, 4.0, 3.0,
        7.0, 6.0, 5.0, 4.0, 3.0, 2.0,
        6.0, 5.0, 4.0, 3.0, 2.0, 1.0,
    ]);
    let expected = na_a * na_b;

    for i in 0..6 {
        for j in 0..6 {
            assert_close_f64(got.data[i][j], expected[(i, j)], 1.0e-12);
        }
    }
}

#[test]
fn matvec4_simd_matches_nalgebra_f32() {
    let a = Matrix::<f32, 4, 4>::new([
        [1.0, 2.0, 3.0, 4.0],
        [2.0, 3.0, 4.0, 5.0],
        [3.0, 4.0, 5.0, 6.0],
        [4.0, 5.0, 6.0, 7.0],
    ]);
    let v = Vector::<f32, 4>::new([1.0, -2.0, 0.5, 3.0]);

    let got = a.mul_vec4_simd(&v);

    let na_a = SMatrix::<f32, 4, 4>::from_row_slice(&[
        1.0, 2.0, 3.0, 4.0,
        2.0, 3.0, 4.0, 5.0,
        3.0, 4.0, 5.0, 6.0,
        4.0, 5.0, 6.0, 7.0,
    ]);
    let na_v = SVector::<f32, 4>::from_row_slice(&[1.0, -2.0, 0.5, 3.0]);
    let expected = na_a * na_v;

    for i in 0..4 {
        assert_close_f32(got.data[i], expected[i], 1.0e-5);
    }
}

#[test]
fn matvec4_simd_matches_nalgebra_f64() {
    let a = Matrix::<f64, 4, 4>::new([
        [1.0, 2.0, 3.0, 4.0],
        [2.0, 3.0, 4.0, 5.0],
        [3.0, 4.0, 5.0, 6.0],
        [4.0, 5.0, 6.0, 7.0],
    ]);
    let v = Vector::<f64, 4>::new([1.0, -2.0, 0.5, 3.0]);

    let got = a.mul_vec4_simd(&v);

    let na_a = SMatrix::<f64, 4, 4>::from_row_slice(&[
        1.0, 2.0, 3.0, 4.0,
        2.0, 3.0, 4.0, 5.0,
        3.0, 4.0, 5.0, 6.0,
        4.0, 5.0, 6.0, 7.0,
    ]);
    let na_v = SVector::<f64, 4>::from_row_slice(&[1.0, -2.0, 0.5, 3.0]);
    let expected = na_a * na_v;

    for i in 0..4 {
        assert_close_f64(got.data[i], expected[i], 1.0e-12);
    }
}

#[test]
fn matvec6_simd_matches_nalgebra_f32() {
    let a = Matrix::<f32, 6, 6>::new([
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0],
        [2.0, 3.0, 4.0, 5.0, 6.0, 7.0],
        [3.0, 4.0, 5.0, 6.0, 7.0, 8.0],
        [4.0, 5.0, 6.0, 7.0, 8.0, 9.0],
        [5.0, 6.0, 7.0, 8.0, 9.0, 10.0],
        [6.0, 7.0, 8.0, 9.0, 10.0, 11.0],
    ]);
    let v = Vector::<f32, 6>::new([1.0, -2.0, 0.5, 3.0, -1.0, 2.0]);

    let got = a.mul_vec6_simd(&v);

    let na_a = SMatrix::<f32, 6, 6>::from_row_slice(&[
        1.0, 2.0, 3.0, 4.0, 5.0, 6.0,
        2.0, 3.0, 4.0, 5.0, 6.0, 7.0,
        3.0, 4.0, 5.0, 6.0, 7.0, 8.0,
        4.0, 5.0, 6.0, 7.0, 8.0, 9.0,
        5.0, 6.0, 7.0, 8.0, 9.0, 10.0,
        6.0, 7.0, 8.0, 9.0, 10.0, 11.0,
    ]);
    let na_v = SVector::<f32, 6>::from_row_slice(&[1.0, -2.0, 0.5, 3.0, -1.0, 2.0]);
    let expected = na_a * na_v;

    for i in 0..6 {
        assert_close_f32(got.data[i], expected[i], 1.0e-4);
    }
}

#[test]
fn matvec6_simd_matches_nalgebra_f64() {
    let a = Matrix::<f64, 6, 6>::new([
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0],
        [2.0, 3.0, 4.0, 5.0, 6.0, 7.0],
        [3.0, 4.0, 5.0, 6.0, 7.0, 8.0],
        [4.0, 5.0, 6.0, 7.0, 8.0, 9.0],
        [5.0, 6.0, 7.0, 8.0, 9.0, 10.0],
        [6.0, 7.0, 8.0, 9.0, 10.0, 11.0],
    ]);
    let v = Vector::<f64, 6>::new([1.0, -2.0, 0.5, 3.0, -1.0, 2.0]);

    let got = a.mul_vec6_simd(&v);

    let na_a = SMatrix::<f64, 6, 6>::from_row_slice(&[
        1.0, 2.0, 3.0, 4.0, 5.0, 6.0,
        2.0, 3.0, 4.0, 5.0, 6.0, 7.0,
        3.0, 4.0, 5.0, 6.0, 7.0, 8.0,
        4.0, 5.0, 6.0, 7.0, 8.0, 9.0,
        5.0, 6.0, 7.0, 8.0, 9.0, 10.0,
        6.0, 7.0, 8.0, 9.0, 10.0, 11.0,
    ]);
    let na_v = SVector::<f64, 6>::from_row_slice(&[1.0, -2.0, 0.5, 3.0, -1.0, 2.0]);
    let expected = na_a * na_v;

    for i in 0..6 {
        assert_close_f64(got.data[i], expected[i], 1.0e-12);
    }
}
